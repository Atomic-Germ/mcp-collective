import { DirectoryLoader } from "langchain/document_loaders/fs/directory";
import { TextLoader } from "langchain/document_loaders/fs/text";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { OpenAIEmbeddings } from "@langchain/openai";
import { Document } from "@langchain/core/documents";
import fs from "node:fs";
import path from "node:path";
import type { Config as RagConfig, SearchRequest, SearchResult, VectorStore } from "../types/index.js";
import { createVectorStore, loadVectorStore } from "./vector-store-factory.js";
import type { HNSWLib } from "@langchain/community/vectorstores/hnswlib";

export class RagService {
  private config: Required<RagConfig>;
  private vectorStore: VectorStore | null = null;
  private openAIApiKey: string;

  constructor(config: RagConfig, openAIApiKey: string) {
    this.config = {
      knowledgeBasePath: config.knowledgeBasePath,
      similarityThreshold: config.similarityThreshold ?? 0.7,
      chunkSize: config.chunkSize ?? 1000,
      chunkOverlap: config.chunkOverlap ?? 200,
      vectorStoreType: config.vectorStoreType ?? "hnswlib",
      vectorStoreConfig: config.vectorStoreConfig ?? {},
    };
    this.openAIApiKey = openAIApiKey;
  }

  /**
   * ナレッジベースのインデックスを作成または更新します
   */
  async initialize(): Promise<void> {
    console.log(`Initializing RAG service with knowledge base: ${this.config.knowledgeBasePath}`);
    
    // ディレクトリが存在するか確認
    if (!fs.existsSync(this.config.knowledgeBasePath)) {
      throw new Error(`Knowledge base path does not exist: ${this.config.knowledgeBasePath}`);
    }

    // ドキュメントをロード
    const loader = new DirectoryLoader(this.config.knowledgeBasePath, {
      ".md": (path) => new TextLoader(path),
      ".mdx": (path) => new TextLoader(path),
      ".txt": (path) => new TextLoader(path),
    });

    console.log("Loading documents...");
    const docs = await loader.load();
    
    if (docs.length === 0) {
      console.warn("No documents found in the knowledge base directory");
      return;
    }
    
    console.log(`Loaded ${docs.length} documents`);

    // テキストをチャンクに分割
    const textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: this.config.chunkSize,
      chunkOverlap: this.config.chunkOverlap,
    });

    console.log("Splitting documents into chunks...");
    const splitDocs = await textSplitter.splitDocuments(docs);
    console.log(`Created ${splitDocs.length} chunks`);

    // Embeddingsを作成
    const embeddings = new OpenAIEmbeddings({
      openAIApiKey: this.openAIApiKey,
    });

    // ベクトルストアを作成
    console.log(`Creating vector store using ${this.config.vectorStoreType}...`);
    this.vectorStore = await createVectorStore(
      this.config.vectorStoreType,
      splitDocs,
      embeddings,
      this.config.vectorStoreConfig
    );
    console.log("Vector store created successfully");

    // ベクトルストアを保存（HNSWLibの場合のみ）
    if (this.config.vectorStoreType === "hnswlib") {
      const vectorStorePath = path.join(this.config.knowledgeBasePath, ".vector-store");
      await (this.vectorStore as HNSWLib).save(vectorStorePath);
      console.log(`Vector store saved to ${vectorStorePath}`);
    }
  }

  /**
   * 既存のベクトルストアをロードします（存在する場合）
   */
  async loadExistingVectorStore(): Promise<boolean> {
    // HNSWLib以外のベクトルストアの場合は、別の方法でロードする必要がある
    if (this.config.vectorStoreType !== "hnswlib") {
      console.log(`Vector store type ${this.config.vectorStoreType} does not support loading from directory`);
      return false;
    }

    const vectorStorePath = path.join(this.config.knowledgeBasePath, ".vector-store");
    
    if (fs.existsSync(vectorStorePath)) {
      console.log(`Loading existing vector store from ${vectorStorePath}`);
      
      const embeddings = new OpenAIEmbeddings({
        openAIApiKey: this.openAIApiKey,
      });
      
      try {
        this.vectorStore = await loadVectorStore(
          this.config.vectorStoreType,
          vectorStorePath,
          embeddings
        );
        console.log("Vector store loaded successfully");
        return true;
      } catch (error) {
        console.error("Failed to load vector store:", error);
        return false;
      }
    }
    
    console.log("No existing vector store found");
    return false;
  }

  /**
   * ナレッジベースを検索します
   */
  async search(request: SearchRequest): Promise<SearchResult[]> {
    if (!this.vectorStore) {
      // ベクトルストアが初期化されていない場合は既存のものをロードするか、新規作成
      const loaded = await this.loadExistingVectorStore();
      if (!loaded) {
        await this.initialize();
        
        // テスト用に、initializeが早期リターンした場合の対応
        if (!this.vectorStore) {
          // 空の結果を返す
          return [];
        }
      }
    }

    const limit = request.limit ?? 5;
    console.log(`Searching for: "${request.query}" (limit: ${limit})`);

    // フィルタリングオプションの処理
    let filteredQuery = request.query;
    if (request.context) {
      console.log(`Using context: "${request.context}"`);
      // コンテキストを考慮した検索（実際の実装はより複雑になる可能性がある）
      filteredQuery = `${request.query} ${request.context}`;
    }

    // 類似度検索を実行
    // この時点でthis.vectorStoreはnullではないはずだが、型チェックのために確認
    if (!this.vectorStore) {
      return [];
    }
    
    const results = await this.vectorStore.similaritySearchWithScore(
      filteredQuery,
      limit
    );

    // 結果を整形
    const searchResults = results
      .filter(([_, score]) => score >= this.config.similarityThreshold)
      .map(([doc, score]) => {
        // 基本的な結果オブジェクト
        const result: SearchResult = {
          content: doc.pageContent,
          score: score as number,
          source: doc.metadata.source as string,
        };
        
        // メタデータから行数・桁数の情報を抽出（存在する場合）
        if (doc.metadata.startLine !== undefined) {
          result.startLine = Number(doc.metadata.startLine);
        }
        if (doc.metadata.endLine !== undefined) {
          result.endLine = Number(doc.metadata.endLine);
        }
        if (doc.metadata.startColumn !== undefined) {
          result.startColumn = Number(doc.metadata.startColumn);
        }
        if (doc.metadata.endColumn !== undefined) {
          result.endColumn = Number(doc.metadata.endColumn);
        }
        
        // 行数・桁数の情報がない場合は、コンテンツから推測
        if (result.startLine === undefined && result.content) {
          // コンテンツの行数をカウント
          const lines = result.content.split('\n');
          result.startLine = 1;
          result.endLine = lines.length;
          
          // 最初の行の長さを桁数として使用
          if (lines.length > 0) {
            result.startColumn = 1;
            result.endColumn = lines[0].length;
          }
        }
        
        // ドキュメントの種類を推測
        const source = result.source.toLowerCase();
        if (source.endsWith('.md') || source.endsWith('.mdx')) {
          result.documentType = 'markdown';
        } else if (source.endsWith('.txt')) {
          result.documentType = 'text';
        } else if (source.endsWith('.js') || source.endsWith('.ts')) {
          result.documentType = 'code';
        } else if (source.endsWith('.json')) {
          result.documentType = 'json';
        }
        
        // メタデータを含める（オプション）
        if (request.include?.metadata) {
          result.metadata = { ...doc.metadata };
        }
        
        return result;
      });

    // フィルタリングオプションの適用
    let finalResults = searchResults;
    
    if (request.filter) {
      // ドキュメントタイプでフィルタリング
      if (request.filter.documentTypes && request.filter.documentTypes.length > 0) {
        finalResults = finalResults.filter(result => 
          result.documentType && request.filter?.documentTypes?.includes(result.documentType)
        );
      }
      
      // ソースパターンでフィルタリング
      if (request.filter.sourcePattern) {
        const pattern = new RegExp(request.filter.sourcePattern.replace(/\*/g, '.*'));
        finalResults = finalResults.filter(result => pattern.test(result.source));
      }
    }
    
    // 追加情報の生成（実際の実装ではLLMを使用する可能性がある）
    if (request.include) {
      for (const result of finalResults) {
        // 要約の生成
        if (request.include.summary) {
          // 簡易的な要約（実際の実装ではLLMを使用）
          const firstLine = result.content.split('\n')[0];
          result.summary = firstLine.length > 100 ? `${firstLine.substring(0, 100)}...` : firstLine;
        }
        
        // キーワードの抽出
        if (request.include.keywords) {
          // 簡易的なキーワード抽出（実際の実装ではより高度な方法を使用）
          const words = result.content
            .toLowerCase()
            .replace(/[^\w\s]/g, '')
            .split(/\s+/)
            .filter(word => word.length > 3);
          
          // 重複を削除して上位5つを取得
          result.keywords = [...new Set(words)].slice(0, 5);
        }
        
        // 関連性の説明
        if (request.include.relevance) {
          // 簡易的な関連性の説明（実際の実装ではLLMを使用）
          result.relevance = `このドキュメントは検索クエリ "${request.query}" に関連する情報を含んでいます。類似度スコア: ${result.score.toFixed(2)}`;
        }
      }
    }
    
    return finalResults;
  }
}
